from astropy.coordinates import SkyCoord
from astropy import constants as const
from astropy.io import fits
from astropy import units as u
from astropy.wcs import WCS
import numpy as np
from radio_beam import Beams
from spectral_cube import SpectralCube
from astropy.cosmology import Planck18 as cosmo
from astropy.table import Table
from src.modules.functions import get_radecfreq
from astropy.io import ascii


def cat_reader(catalog_file, original):
    if catalog_file.split(".")[-1] == "xml":
        print("\tReading catalog in XML format.")
        print("\tWARNING: always assumes an xml file comes from SoFiA-2.")
        try:
            catalog = Table.read(catalog_file)
            sofia = 2
        except FileNotFoundError:
            print("\tERROR: {} catalog not found. Typo or wrong directory?\n".format(catalog_file))
            exit()
        except:
            no_cat = True
    elif (catalog_file.split(".")[-1] == "txt") | (catalog_file.split(".")[-1] == "ascii"):
        print("\tReading catalog in ascii format.")
        try:
            catalog = Table.read(catalog_file, format='ascii', header_start=18)  # Depends on SoFiA version!!! Do a brute force tes?
            print("\tCatalog generated by SoFiA-2?")
            sofia = 2
            no_cat = False
        except FileNotFoundError:
            print("\tERROR: {} catalog not found. Typo or wrong directory?\n".format(catalog_file))
            exit()
        except:
            no_cat = True
        if no_cat == True:
            try:
                catalog = Table.read(catalog_file, format='ascii', header_start=1)  # Depends on SoFiA version!!! Do a brute force tes?
                print("\tCatalog generated by SoFiA-1 or another source?")
                sofia = 1
                no_cat = False
            except:
                no_cat = True
        if no_cat == True:
            print("\tERROR: Trouble reading ascii format catalog.  A bug or generated by a different version of SoFiA?")
    else:
        print("\tERROR: Catalog must be in xml or ascii format.\n")
        exit()

    # Check what's in the catalog; calculate ra, dec if necessary:
    if (('ra' not in catalog.colnames) and ('l' not in catalog.colnames)) and (not original):
        print("\tERROR: Looks like catalog doesn't contain 'ra' and 'dec' or 'l' and 'b' columns. Re-run SoFiA with \n" \
            "\t\t'parameter.wcs = True' or you must include the path to the original fits file to derive \n" \
            "\t\tra, dec from the pixel values in the catalog.")
        print("*****************************************************************\n")
        exit()
    elif ('ra' not in catalog.colnames) and (original):
        # This may be deprecated given that we insistence on running parameter.wcs, physical, offset = True
        print("\tWARNING: Looks like catalog doesn't contain 'ra' and 'dec' columns. But can derive them with \n" \
            "\t\tthe pixel positions in the catalog provided.")
        print("\tWARNING: This probably means you ran SoFiA with 'parameter.wcs = False' which means the units \n" \
            "\t\t in your maps may be completely wacky! (Channel width knowledge is not maintained.)")
        ra, dec, freq = get_radecfreq(catalog, original)
        catalog['ra'] = ra
        catalog['dec'] = dec
        catalog['freq'] = freq
    # Add dummy columns to catalog for plotting source centers generalized to ICRS or Galactic later:
    catalog['pos_x'] = None
    catalog['pos_y'] = None

    # Rename the spectral column if cube was in velocity. For now treat all velocity axes the same (dumb temporary fix)
    if 'v_app' in catalog.colnames:
        catalog.rename_column('v_app', 'v_col')
    elif 'v_rad' in catalog.colnames:
        catalog.rename_column('v_rad', 'v_col')
    elif 'v_opt' in catalog.colnames:
        catalog.rename_column('v_opt', 'v_col')
    elif 'freq' not in catalog.colnames:
        print("ERROR: Column name for spectral axis not recognized.\n")
        exit()

    return catalog

def common_beam_cube(fitsfile, new_cube_name):
    hdulist=fits.open(fitsfile)
    beams = Beams.from_fits_bintable(hdulist[1])
    cube=SpectralCube.read(fitsfile)
    cube.allow_huge_operations=True
    common_beam=beams.common_beam()
    print(common_beam)
    new_cube = cube.convolve_to(common_beam)
    new_cube.write(new_cube_name+'.fits', overwrite=True)
    nhdu=fits.open(new_cube_name+'.fits')
    nhdu[0].header['BUNIT']='Jy/beam'
    nhdu.writeto(new_cube_name+'.fits', overwrite=True)
    hdulist.close()
    nhdu.close()
    return new_cube

def hicosmo(source):
    #Estimate error for everything
    v_opt=source['v_col']*u.m/u.s
    z=v_opt/const.c #v_opt in m/s if km/s v_opt.to('m/s')
    scale_z=(cosmo.kpc_proper_per_arcmin(z)/60).value*u.kpc/u.arcsec
    D_H=cosmo.comoving_distance(z) #Mpc

    #D_H=np.round_(D_H.value,2)*u.Mpc
    #z=np.round_(z,4)
    
    return z,scale_z,D_H    

def himass(source):

    z,scale_z,D_H=hicosmo(source)
    lineflux=source['f_sum']/1000 #Jy*m/s to Jy*km/s 
    #if f_sum is not there add option for np.nansum()/pix_per_beam
    #Also account for f_sum in other units?
    M_HI = 2.36e5*(D_H.value**2)*lineflux #Give users option to input D_H
    lM_HI = np.log10(M_HI.value)*u.M_sun
    return M_HI

def cat2lat(cat,original,tabname,rmarr=None):
 
    ncat=cat.copy()

    ncat.remove_rows(rmarr.astype(int)-1)
    vres=fits.open(original)[0].header['CDELT3']*u.m/u.s
    nchan=ncat['z_max']-ncat['z_min']
    delv=nchan*np.absolute(vres).to(u.km/u.s)
    
    M_HI=himass(ncat)
    z,scale_z,D_H=hicosmo(ncat)

    # Rounding Everything
    lM_HI = np.round_(np.log10(M_HI.value),2)*u.M_sun
    D_H=np.round_(D_H,2)
    z=np.round_(z,4)
    delv=np.round_(delv,2)
    fac=2.11e-4*(1+z)**2
    ncat['w20']=np.round_(((ncat['w20'])*u.m/u.s).to(u.km/u.s),2)
    ncat['w50']=np.round_(((ncat['w50'])*u.m/u.s).to(u.km/u.s),2)
    ncat['v_col']=np.round_(((ncat['v_col'])*u.m/u.s).to(u.km/u.s),2)

    ncat['kin_pa']=np.round_((ncat['kin_pa'])*u.deg,2)

    ncat['f_sum']=np.round_(((ncat['f_sum'])*u.Jy*u.m/u.s).to(u.mJy*u.km/u.s),2)
    ncat['err_f_sum']=np.round_(((ncat['err_f_sum'])*u.Jy*u.m/u.s).to(u.mJy*u.km/u.s),2)

    #flux=(ncat['f_sum']/fac).value*u.mJy*u.Hz #Value is too big Eq 38 from Meyer+2017

    coords=SkyCoord(ncat['ra']*u.deg,ncat['dec']*u.deg)
    ncat['ra']=coords.ra.to_string(unit=u.hour, sep=':')
    ncat['dec']=coords.dec.to_string(unit=u.degree, sep=':')

    col_names=['name','f_sum','err_f_sum','w20','w50','ra', 'dec','v_col','kin_pa']
    ncat.keep_columns(col_names)
    ncat.add_columns([lM_HI,z,D_H,delv],names=['M_HI','z','D_Hubble','v_extent'])

    ncat=ncat['name','ra', 'dec','v_col','z','D_Hubble','M_HI','f_sum','err_f_sum','w20','w50','kin_pa','v_extent']

    ascii.write(ncat, tabname+'.tex', Writer=ascii.Latex, overwrite=True)

    return ncat